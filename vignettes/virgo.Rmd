---
title: "Introducing virgo for interactive exploratory graphics"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introducing virgo for interactive exploratory graphics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The virgo package developed and extends the grammar of interactive graphics based on the **Vega-Lite** library in Javascript. It is a functional grammar built on top of the **vegawidget** package. In this vignette we detail each component of the grammar, eventually building up
to some sophisticated interactive examples.

Throughout this vignette we will be exploring three months of microclimate sensor data collected from December 2019 until February 2020 from Melbourne City Council. This data is built into to **virgo** and consists of measurements for things like temperature and relative humidity at 5 different locations. 
```{r setup, echo = TRUE}
library(virgo)
library(lubridate)
library(dplyr)
melbweather
```

## Data, Encodings and Marks

To construct a visualisation, we begin with tidy data and map columns to visual elements using encodings:

```{r}
melbweather %>%
  filter(date == "2019-12-01") %>% 
  vega(encoding = enc(x = ambient_temperature))
```

The data is piped into the `vega()` function and aesthetic mappings are
specified with the `enc()`. Valid encodings depend on the **mark** or graphical element being used. As there are no marks for this **virgo** chart, blank canvas is printed. The `vega()` function is required to be called in order to produce a valid visualisation, however as well we see later both data and marks can be specified elsewhere.

To produce interesting charts, we can add **marks** which are visual layers that are added to the chart. 

Let's go back to our data:

```{r}
melbweather
```

To begin, we will collapse our quarter hourly 
measurements for each site to hourly averages using **dplyr**:

```{r}
hourly_weather <- melbweather %>% 
  group_by(site, date, hour_of_day = hour(date_time) ) %>% 
  summarise(
    across(
      c(ambient_temperature:pm10), 
      mean, 
      na.rm = TRUE
    )
  ) %>% 
  ungroup()

hourly_weather
```
Suppose we are interested in the relationship between ambient temperature and relative humidity. It is theorised that as ambient temperature increases, relative humidity decreases.

We can check whether this is the case with our data by creating a scatter plot.

```{r}
hourly_weather %>% 
  vega() %>% 
  mark_point(enc(x = ambient_temperature, y = relative_humidity))
```

For users, of **ggplot2** the above incantation should look somewhat familiar. We specify our data at the top level using `vega()` and then add layers using the pipe `%>% ` in combination with marks. Inside the `mark_point()` function we specify the aesthetic mapping or **encoding** that says the x axis should correspond to ambient temperature and the y axis should correspond to relative humidity.

The **virgo** library will automatically add legends depending on the type of encoding and input variable. If we color by a continuous variable a scale is automatically determined and placed on the right hand side of the plot. 

```{r}
hourly_weather %>% 
  vega() %>% 
  mark_point(
    enc(x = ambient_temperature, 
        y = relative_humidity, 
        color = wind_speed)
  )
```

Likewise, we can evaluate expressions inside of the encoding function for example evaluating the month of the date column
with **lubridate**:

```{r}
hourly_weather %>% 
  vega() %>% 
  mark_point(
    enc(
      x = ambient_temperature, 
      y = relative_humidity, 
      color = month(date, label = TRUE)
    )
  )
```


It appears that there is a slight non-linear and negative relationship between ambient temperature and relative humidity, however, there is a lot over-plotting in the first example, so perhaps it would be best to add some opacity to the previous scatter plot. Graphical elements that don't depend on columns of the data can be added via extra arguments to the mark function:


```{r}
hourly_weather %>% 
  vega() %>% 
  mark_point(
    enc(x = ambient_temperature, y = relative_humidity),
    opacity = 0.1
  )
```

Multiple marks can be added to a visualisation by piping a sequence of marks together. For example, adding a loess regression
to a scatter plot.

```{r}
p <- hourly_weather %>% 
  vega(enc(x = ambient_temperature, y = relative_humidity)) %>% 
  mark_point(opacity = 0.1) %>% 
  mark_smooth(method = "loess", color = "blue")
p
```

Here we've specified the encoding at the top level with the `vega()` function, so they are available to all downstream layers. We can have layer specific encodings, by passing the `enc()` to specific layers. In addition to a single regression line, we could generate separate lines for each measurement within each month of the year:

```{r}
p %>% 
  mark_smooth(
    enc(color = month(date, label = TRUE)),
    method = "loess"
  )
```

## Facets

Sometimes we want to visualise multiple categorical variables at the same time, by creating small multiples (facets) views. Say we were interested in the distribution of wind speed, we could
create a histogram:

```{r}
ws <- hourly_weather %>% 
  vega() %>% 
  mark_histogram(enc(x = wind_speed), bin = list(step = 1))
ws
```

How similar are the wind speeds across each measurement site? We can facet by site to find out:

```{r}
ws %>% 
  facet_views(column = site)
```

Faceting requires specifying a row and/or column encoding, that determines how the subplots are drawn on the canvas.

## Multiple Views

Often it is helpful to place views side by side that shows all
of the data rather than subplots like those produced by faceting.

**virgo** provides functions to align plots horizontally or vertically with the `hconcat()` or `vconcat()` functions.

```{r}
left <- hourly_weather %>% 
  vega() %>% 
  mark_point(enc(x = ambient_temperature, y = relative_humidity),
             opacity = 0.1)
right <- hourly_weather %>%
  vega() %>% 
  mark_point(enc(x = wind_speed, y = relative_humidity),
             opacity = 0.1)
hconcat(left, right) # not working?
```

## Client side data transformations

The **virgo** package exports special functions that are computed directly by **Vega-Lite** rather than R. These functions are prefixed with `vg`, and should always be called inside of `enc()`.

By using the `vg` functions, we can get **Vega-Lite** to compute the average temperature for each hour across all of the days and sites in the data set.
```{r}
hourly_temp <- melbweather %>% 
  vega(
    enc(
      x = vg_hours(date_time), 
      y = vg_mean(ambient_temperature)
    )
  ) %>% 
  mark_point() %>% 
  mark_line()
hourly_temp
```


Generally, we believe it is best to perform data transformations outside of the visualisation environment as the transformations are explicit (i.e. when using the **tidyverse**). However, as we will see later these client side transformations become especially useful when combined with interactivity.

## Interactivity via selections




